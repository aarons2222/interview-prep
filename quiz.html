<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview Quiz - Android & iOS</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 40px 20px;
        }
        .container { max-width: 800px; margin: 0 auto; }
        .back {
            color: #fff;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 1.2rem;
            margin-bottom: 20px;
            transition: all 0.2s;
        }
        .back:hover {
            background: rgba(255,255,255,0.2);
            border-color: #00d9ff;
        }
        h1 { 
            font-size: 2rem; 
            margin-bottom: 10px; 
            text-align: center;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        
        .progress-bar {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            height: 8px;
            margin-bottom: 30px;
            overflow: hidden;
        }
        .progress-fill {
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .score-display {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            color: #888;
        }
        .score-display span { color: #00ff88; font-weight: 600; }
        
        .question-card {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .question-number {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 15px;
        }
        .tag-ios { background: #FF5722; }
        .tag-android { background: #4CAF50; color: #000; }
        .tag-general { background: #00d9ff; color: #000; }
        
        .question-text {
            font-size: 1.2rem;
            margin-bottom: 25px;
            line-height: 1.5;
        }
        
        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .option {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .option:hover:not(.disabled) {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
        }
        .option.selected {
            border-color: #00d9ff;
            background: rgba(0,217,255,0.1);
        }
        .option.correct {
            border-color: #00ff88;
            background: rgba(0,255,136,0.1);
        }
        .option.incorrect {
            border-color: #ff4444;
            background: rgba(255,68,68,0.1);
        }
        .option.disabled { cursor: default; }
        
        .option-letter {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            flex-shrink: 0;
        }
        .option.correct .option-letter { background: #00ff88; color: #000; }
        .option.incorrect .option-letter { background: #ff4444; }
        
        .explanation {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0,217,255,0.1);
            border-left: 4px solid #00d9ff;
            border-radius: 0 12px 12px 0;
            display: none;
        }
        .explanation.show { display: block; }
        .explanation strong { color: #00d9ff; }
        
        .nav-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }
        .btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            color: #000;
        }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.15); }
        
        .results {
            text-align: center;
            display: none;
        }
        .results.show { display: block; }
        .results h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        .results .final-score {
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 20px 0;
        }
        .results .message {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 30px;
        }
        .review-btn {
            display: inline-block;
            padding: 16px 40px;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            color: #000;
            text-decoration: none;
            border-radius: 12px;
            font-weight: 600;
            margin: 10px;
            border: none;
            cursor: pointer;
            font-size: 1rem;
        }
        .review-btn.secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }
        
        .hidden { display: none !important; }
        
        /* History styles */
        .history-section {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .history-section h3 {
            margin-bottom: 20px;
            color: #888;
        }
        .history-item {
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .history-score {
            font-weight: 600;
            font-size: 1.2rem;
        }
        .history-date { color: #666; font-size: 0.9rem; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back">‚úï</a>
        <h1>üìù Interview Quiz</h1>
        <p class="subtitle">Test your Android & iOS knowledge ‚Äî 40 questions</p>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        
        <div class="score-display">
            Question <span id="currentQ">1</span> of <span id="totalQ">40</span> | 
            Score: <span id="score">0</span>
        </div>
        
        <div id="quiz-container">
            <!-- Questions loaded by JS -->
        </div>
        
        <div class="results" id="results">
            <h2>Quiz Complete!</h2>
            <div class="final-score" id="finalScore">0%</div>
            <p class="message" id="resultMessage"></p>
            <div style="margin-bottom: 20px;">
                <button class="review-btn" onclick="viewMatrix()">üìä View Strengths & Weaknesses</button>
            </div>
            <div>
                <button class="review-btn secondary" onclick="restartQuiz()">Try Again</button>
                <a href="index.html" class="review-btn secondary">Back to Prep</a>
            </div>
            
            <div class="history-section" id="historySection">
                <h3>üìà Previous Attempts</h3>
                <div id="historyList"></div>
            </div>
        </div>
    </div>

    <script>
        const questions = [
            // ==================== iOS QUESTIONS ====================
            // UIKit & SwiftUI
            {
                tag: 'ios', topic: 'UIKit/SwiftUI',
                question: 'What is the main difference between UIKit and SwiftUI?',
                options: ['UIKit is newer than SwiftUI', 'UIKit is imperative, SwiftUI is declarative', 'SwiftUI only works on iPad', 'UIKit uses Swift, SwiftUI uses Objective-C'],
                correct: 1,
                explanation: 'UIKit is imperative ‚Äî you tell it HOW to build the UI step by step. SwiftUI is declarative ‚Äî you describe WHAT the UI should look like.'
            },
            {
                tag: 'ios', topic: 'UIKit/SwiftUI',
                question: 'Which property wrapper makes a SwiftUI view update when data changes?',
                options: ['@Published', '@State', '@Binding', '@ObservedObject'],
                correct: 1,
                explanation: '@State is used for simple value types owned by the view. When @State changes, SwiftUI re-renders the view.'
            },
            {
                tag: 'ios', topic: 'UIKit/SwiftUI',
                question: 'What is the purpose of @Binding in SwiftUI?',
                options: ['To create a new data source', 'To share state between parent and child views', 'To fetch data from an API', 'To animate views'],
                correct: 1,
                explanation: '@Binding creates a two-way connection to a @State property owned by a parent view, allowing child views to read and write the value.'
            },
            
            // Memory Management
            {
                tag: 'ios', topic: 'Memory',
                question: 'What does ARC stand for in iOS memory management?',
                options: ['Apple Resource Controller', 'Automatic Reference Counting', 'Advanced Runtime Compiler', 'Asynchronous Request Cache'],
                correct: 1,
                explanation: 'ARC (Automatic Reference Counting) tracks how many references point to an object. When the count hits zero, the object is deallocated.'
            },
            {
                tag: 'ios', topic: 'Memory',
                question: 'How do you prevent retain cycles in closures?',
                options: ['Use @escaping keyword', 'Use [weak self] or [unowned self] in capture list', 'Always use structs instead of classes', 'Call deinit manually'],
                correct: 1,
                explanation: '[weak self] captures self weakly (becomes optional). [unowned self] doesn\'t increase retain count but crashes if accessed after deallocation.'
            },
            {
                tag: 'ios', topic: 'Memory',
                question: 'What is the difference between weak and unowned references?',
                options: ['Weak is faster than unowned', 'Weak becomes nil when deallocated, unowned crashes', 'Unowned is for value types only', 'There is no difference'],
                correct: 1,
                explanation: 'Weak references become nil when the object is deallocated (must be optional). Unowned references crash if accessed after deallocation (non-optional).'
            },
            
            // App Lifecycle
            {
                tag: 'ios', topic: 'Lifecycle',
                question: 'Which iOS app state means the app is in foreground but NOT receiving events?',
                options: ['Active', 'Background', 'Inactive', 'Suspended'],
                correct: 2,
                explanation: 'Inactive means the app is in the foreground but not receiving events ‚Äî for example, during an incoming call or system alert.'
            },
            {
                tag: 'ios', topic: 'Lifecycle',
                question: 'Which method is called when an iOS app is about to move to the background?',
                options: ['applicationWillResignActive', 'applicationDidEnterBackground', 'applicationWillTerminate', 'applicationDidBecomeActive'],
                correct: 1,
                explanation: 'applicationDidEnterBackground is called when the app has moved to the background. applicationWillResignActive is called just before losing focus.'
            },
            
            // Architecture
            {
                tag: 'ios', topic: 'Architecture',
                question: 'In MVVM architecture on iOS, which layer does the ViewController belong to?',
                options: ['Model', 'View', 'ViewModel', 'Controller (separate layer)'],
                correct: 1,
                explanation: 'In MVVM, the ViewController is part of the View layer. The ViewModel contains the presentation logic that would otherwise bloat the VC.'
            },
            {
                tag: 'ios', topic: 'Architecture',
                question: 'What problem does the Coordinator pattern solve?',
                options: ['Memory leaks', 'Navigation logic scattered across view controllers', 'Slow network requests', 'Database corruption'],
                correct: 1,
                explanation: 'The Coordinator pattern extracts navigation logic from view controllers into dedicated coordinator objects, improving reusability and testability.'
            },
            
            // Data & Security
            {
                tag: 'ios', topic: 'Data/Security',
                question: 'What is the correct way to store sensitive data like auth tokens on iOS?',
                options: ['UserDefaults', 'Core Data', 'Keychain', 'FileManager documents directory'],
                correct: 2,
                explanation: 'Keychain is encrypted secure storage for sensitive data. Never use UserDefaults for tokens or passwords.'
            },
            {
                tag: 'ios', topic: 'Data/Security',
                question: 'What is App Transport Security (ATS)?',
                options: ['A DRM system for apps', 'A requirement to use HTTPS for network connections', 'A code signing mechanism', 'An encryption library'],
                correct: 1,
                explanation: 'ATS enforces secure network connections by default. Apps must use HTTPS unless exceptions are explicitly declared in Info.plist.'
            },
            
            // Concurrency
            {
                tag: 'ios', topic: 'Concurrency',
                question: 'Which queue should UI updates run on?',
                options: ['Global queue', 'Background queue', 'Main queue', 'Any queue'],
                correct: 2,
                explanation: 'All UI updates must happen on the main queue (main thread). Updating UI from background threads causes crashes or visual glitches.'
            },
            {
                tag: 'ios', topic: 'Concurrency',
                question: 'What is the purpose of DispatchGroup?',
                options: ['To create UI components', 'To wait for multiple async tasks to complete', 'To encrypt data', 'To manage memory'],
                correct: 1,
                explanation: 'DispatchGroup lets you wait for multiple async tasks to complete before executing a completion block. Use enter/leave/notify.'
            },
            
            // Frameworks
            {
                tag: 'ios', topic: 'Frameworks',
                question: 'Which framework provides reactive programming on iOS 13+?',
                options: ['RxSwift', 'Combine', 'SwiftUI', 'Foundation'],
                correct: 1,
                explanation: 'Combine is Apple\'s native reactive framework (iOS 13+). It handles async events as streams with Publishers, Subscribers, and Operators.'
            },
            {
                tag: 'ios', topic: 'Frameworks',
                question: 'What is Core Data used for?',
                options: ['Network requests', 'Object graph and persistence management', 'UI layout', 'Push notifications'],
                correct: 1,
                explanation: 'Core Data is Apple\'s ORM framework for object graph management with SQLite backend. It handles relationships, caching, and change tracking.'
            },
            
            // ==================== ANDROID QUESTIONS ====================
            // Components
            {
                tag: 'android', topic: 'Components',
                question: 'What are the four fundamental Android components?',
                options: ['Activity, Fragment, View, Intent', 'Activity, Service, Broadcast Receiver, Content Provider', 'MainActivity, Application, Context, Bundle', 'View, ViewModel, Repository, Database'],
                correct: 1,
                explanation: 'The four components are: Activity (UI), Service (background work), Broadcast Receiver (system events), Content Provider (shared data).'
            },
            {
                tag: 'android', topic: 'Components',
                question: 'What is the purpose of a Content Provider?',
                options: ['To display content on screen', 'To share data between applications', 'To provide internet connectivity', 'To manage app permissions'],
                correct: 1,
                explanation: 'Content Providers manage shared app data and expose it to other apps. Examples: Contacts, MediaStore. Accessed via ContentResolver.'
            },
            {
                tag: 'android', topic: 'Components',
                question: 'What is the difference between a Service and an IntentService?',
                options: ['IntentService runs on main thread', 'IntentService auto-stops when work is done', 'Service is deprecated', 'There is no difference'],
                correct: 1,
                explanation: 'IntentService runs on a worker thread and automatically stops itself when all work is done. Regular Service runs on main thread and you manage its lifecycle.'
            },
            
            // Lifecycle
            {
                tag: 'android', topic: 'Lifecycle',
                question: 'Which Activity lifecycle method is called when the activity becomes visible?',
                options: ['onCreate()', 'onStart()', 'onResume()', 'onVisible()'],
                correct: 1,
                explanation: 'onStart() is called when the activity is becoming visible. onResume() is when it becomes interactive. onCreate() is initial setup.'
            },
            {
                tag: 'android', topic: 'Lifecycle',
                question: 'What happens to an Activity when you rotate the device?',
                options: ['Nothing, it stays the same', 'It is destroyed and recreated', 'Only the layout changes', 'The app crashes'],
                correct: 1,
                explanation: 'Configuration changes like rotation destroy and recreate the Activity. Use ViewModel to survive this, or handle it with configChanges in manifest.'
            },
            {
                tag: 'android', topic: 'Lifecycle',
                question: 'Which lifecycle method should you use to release resources like camera or sensors?',
                options: ['onCreate()', 'onPause()', 'onStop()', 'onDestroy()'],
                correct: 2,
                explanation: 'Release resources in onStop() when the activity is no longer visible. onPause() is too early (activity may become visible again quickly).'
            },
            
            // Kotlin
            {
                tag: 'android', topic: 'Kotlin',
                question: 'What is the main advantage of Kotlin over Java for Android?',
                options: ['Kotlin is faster at runtime', 'Kotlin has null safety built-in', 'Kotlin doesn\'t need the JVM', 'Kotlin uses less memory'],
                correct: 1,
                explanation: 'Kotlin has null safety in the type system. Nullable types (String?) must be explicitly handled, preventing NullPointerException.'
            },
            {
                tag: 'android', topic: 'Kotlin',
                question: 'What does the "data class" keyword do in Kotlin?',
                options: ['Creates a database table', 'Auto-generates equals, hashCode, toString, copy', 'Makes the class immutable', 'Enables serialization'],
                correct: 1,
                explanation: 'Data classes auto-generate equals(), hashCode(), toString(), copy(), and componentN() functions based on constructor properties.'
            },
            {
                tag: 'android', topic: 'Kotlin',
                question: 'What is a sealed class used for?',
                options: ['To prevent inheritance', 'To define restricted class hierarchies for when expressions', 'To encrypt data', 'To create singletons'],
                correct: 1,
                explanation: 'Sealed classes define restricted hierarchies. All subclasses must be declared in the same file. Useful with when expressions for exhaustive checking.'
            },
            
            // UI
            {
                tag: 'android', topic: 'UI',
                question: 'Why does RecyclerView perform better than ListView?',
                options: ['RecyclerView uses less XML', 'RecyclerView recycles views and uses ViewHolder pattern', 'RecyclerView is written in Kotlin', 'RecyclerView doesn\'t support animations'],
                correct: 1,
                explanation: 'RecyclerView reuses off-screen item views and caches view references with ViewHolder to avoid repeated findViewById calls.'
            },
            {
                tag: 'android', topic: 'UI',
                question: 'What is the purpose of DiffUtil in RecyclerView?',
                options: ['To add animations', 'To calculate minimal updates between old and new lists', 'To handle click events', 'To create layouts'],
                correct: 1,
                explanation: 'DiffUtil calculates the difference between two lists and dispatches minimal update operations, improving performance and enabling animations.'
            },
            {
                tag: 'android', topic: 'UI',
                question: 'What is Jetpack Compose?',
                options: ['A music composition app', 'A declarative UI toolkit for Android', 'A database library', 'A testing framework'],
                correct: 1,
                explanation: 'Jetpack Compose is Android\'s modern declarative UI toolkit. You describe UI as functions of state, and Compose handles updates.'
            },
            
            // Architecture
            {
                tag: 'android', topic: 'Architecture',
                question: 'What is the purpose of ViewModel in Android Architecture Components?',
                options: ['To display views on screen', 'To survive configuration changes and hold UI state', 'To make network requests', 'To store data in SQLite'],
                correct: 1,
                explanation: 'ViewModel survives configuration changes (like rotation) and holds UI state. It doesn\'t reference the View, making it testable.'
            },
            {
                tag: 'android', topic: 'Architecture',
                question: 'What is LiveData?',
                options: ['A real-time database', 'A lifecycle-aware observable data holder', 'A streaming video library', 'A crash reporting tool'],
                correct: 1,
                explanation: 'LiveData is lifecycle-aware ‚Äî it only updates observers in active lifecycle states (STARTED/RESUMED), preventing crashes and memory leaks.'
            },
            {
                tag: 'android', topic: 'Architecture',
                question: 'In Clean Architecture, which layer should have no Android dependencies?',
                options: ['Presentation', 'Data', 'Domain', 'UI'],
                correct: 2,
                explanation: 'The Domain layer contains business logic and use cases. It should be pure Kotlin with no Android dependencies, making it highly testable.'
            },
            
            // Concurrency
            {
                tag: 'android', topic: 'Concurrency',
                question: 'Which Kotlin feature simplifies asynchronous programming?',
                options: ['Data classes', 'Extension functions', 'Coroutines', 'Sealed classes'],
                correct: 2,
                explanation: 'Coroutines make async code read like synchronous code using suspend functions. Combined with Dispatchers, they replace callbacks and RxJava.'
            },
            {
                tag: 'android', topic: 'Concurrency',
                question: 'What is the difference between Dispatchers.IO and Dispatchers.Default?',
                options: ['IO is for CPU work, Default is for disk/network', 'IO is for disk/network, Default is for CPU work', 'They are the same', 'IO is deprecated'],
                correct: 1,
                explanation: 'Dispatchers.IO is optimized for disk/network I/O (more threads). Dispatchers.Default is for CPU-intensive work (threads = CPU cores).'
            },
            {
                tag: 'android', topic: 'Concurrency',
                question: 'What is the purpose of viewModelScope?',
                options: ['To create ViewModels', 'To auto-cancel coroutines when ViewModel is cleared', 'To observe LiveData', 'To inject dependencies'],
                correct: 1,
                explanation: 'viewModelScope is a CoroutineScope tied to ViewModel lifecycle. Coroutines launched in it are automatically cancelled when ViewModel is cleared.'
            },
            
            // DI & Libraries
            {
                tag: 'android', topic: 'Libraries',
                question: 'What is the recommended DI framework for Android?',
                options: ['Koin', 'Dagger', 'Hilt', 'Guice'],
                correct: 2,
                explanation: 'Hilt is Google\'s recommended DI framework. Built on Dagger, it reduces boilerplate and provides scopes for Android components.'
            },
            {
                tag: 'android', topic: 'Libraries',
                question: 'What does Room provide?',
                options: ['Network caching', 'SQLite abstraction with compile-time verification', 'Image loading', 'JSON parsing'],
                correct: 1,
                explanation: 'Room is an SQLite abstraction that verifies SQL at compile time. It uses annotations (@Entity, @Dao, @Database) and supports LiveData/Flow.'
            },
            
            // Build & Release
            {
                tag: 'android', topic: 'Build',
                question: 'What does R8 do in the Android build process?',
                options: ['Compiles Java to bytecode', 'Shrinks, obfuscates, and optimizes code', 'Generates data binding classes', 'Creates APK signatures'],
                correct: 1,
                explanation: 'R8 shrinks unused code/resources, obfuscates names, and optimizes bytecode for smaller, faster APKs. Configured via proguard-rules.pro.'
            },
            {
                tag: 'android', topic: 'Build',
                question: 'What is the difference between minSdk, targetSdk, and compileSdk?',
                options: ['They are all the same', 'minSdk is lowest supported, targetSdk is tested version, compileSdk is build version', 'minSdk is for tablets only', 'targetSdk must equal compileSdk'],
                correct: 1,
                explanation: 'minSdk = minimum Android version supported. targetSdk = version you\'ve tested against (enables new behaviors). compileSdk = API used to compile.'
            },
            
            // ==================== GENERAL QUESTIONS ====================
            {
                tag: 'general', topic: 'Architecture',
                question: 'What does MVVM stand for?',
                options: ['Model-View-Virtual Machine', 'Model-View-ViewModel', 'Multiple Views Virtual Model', 'Mobile View Visual Manager'],
                correct: 1,
                explanation: 'Model-View-ViewModel. The ViewModel holds presentation logic and UI state, exposing data for the View to observe.'
            },
            {
                tag: 'general', topic: 'Architecture',
                question: 'What is the Single Responsibility Principle?',
                options: ['A class should have only one instance', 'A class should have only one reason to change', 'A function should have one parameter', 'An app should have one activity'],
                correct: 1,
                explanation: 'SRP states that a class should have only one reason to change ‚Äî it should do one thing well. Part of SOLID principles.'
            },
            {
                tag: 'general', topic: 'Testing',
                question: 'What is the main benefit of Dependency Injection?',
                options: ['Faster app startup', 'Smaller APK/IPA size', 'Easier testing with mock objects', 'Better UI animations'],
                correct: 2,
                explanation: 'DI makes testing easier by allowing you to inject mock/fake dependencies. It also improves flexibility and decouples components.'
            },
            {
                tag: 'general', topic: 'Testing',
                question: 'Which testing type verifies individual functions in isolation?',
                options: ['UI Tests', 'Integration Tests', 'Unit Tests', 'End-to-End Tests'],
                correct: 2,
                explanation: 'Unit Tests test individual functions/classes in isolation using mocks. They\'re fast and should cover business logic.'
            },
            {
                tag: 'general', topic: 'Security',
                question: 'What is certificate pinning used for?',
                options: ['Encrypting local database', 'Preventing man-in-the-middle attacks', 'Signing the app for store release', 'Storing passwords securely'],
                correct: 1,
                explanation: 'Certificate pinning verifies the server\'s certificate against a known value, preventing MITM attacks even with rogue CAs.'
            },
            {
                tag: 'general', topic: 'Security',
                question: 'What is the safest way to store API keys in a mobile app?',
                options: ['Hardcode them in source code', 'Store in SharedPreferences/UserDefaults', 'Don\'t store them ‚Äî use a backend proxy', 'Put them in a text file'],
                correct: 2,
                explanation: 'Never store secret API keys in mobile apps ‚Äî they can be extracted. Use a backend server to proxy requests with the secret key.'
            },
            {
                tag: 'general', topic: 'API',
                question: 'What does REST stand for?',
                options: ['Remote Execution Service Transfer', 'Representational State Transfer', 'Request-Response State Tracking', 'Reliable Encrypted Secure Transport'],
                correct: 1,
                explanation: 'REST (Representational State Transfer) is an architectural style using HTTP methods (GET, POST, PUT, DELETE) for stateless client-server communication.'
            },
            {
                tag: 'general', topic: 'API',
                question: 'What HTTP status code indicates "resource not found"?',
                options: ['200', '401', '404', '500'],
                correct: 2,
                explanation: '404 = Not Found. 200 = OK. 401 = Unauthorized. 500 = Internal Server Error.'
            }
        ];

        let currentQuestion = 0;
        let score = 0;
        let answered = false;
        let shuffledQuestions = [];
        let results = []; // Track each answer

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function init() {
            shuffledQuestions = shuffleArray(questions);
            document.getElementById('totalQ').textContent = shuffledQuestions.length;
            results = [];
            showQuestion();
        }

        function showQuestion() {
            const q = shuffledQuestions[currentQuestion];
            const tagClass = q.tag === 'ios' ? 'tag-ios' : q.tag === 'android' ? 'tag-android' : 'tag-general';
            const tagLabel = q.tag === 'ios' ? 'üçé iOS' : q.tag === 'android' ? 'ü§ñ Android' : 'üì± General';
            
            const html = `
                <div class="question-card">
                    <span class="question-number ${tagClass}">${tagLabel} ‚Äî ${q.topic}</span>
                    <p class="question-text">${q.question}</p>
                    <div class="options">
                        ${q.options.map((opt, i) => `
                            <div class="option" onclick="selectOption(${i})" data-index="${i}">
                                <span class="option-letter">${String.fromCharCode(65 + i)}</span>
                                <span>${opt}</span>
                            </div>
                        `).join('')}
                    </div>
                    <div class="explanation" id="explanation">
                        <strong>üí° Explanation:</strong> ${q.explanation}
                    </div>
                    <div class="nav-buttons">
                        <button class="btn btn-primary" id="nextBtn" onclick="nextQuestion()" disabled>
                            ${currentQuestion === shuffledQuestions.length - 1 ? 'See Results' : 'Next Question'}
                        </button>
                    </div>
                </div>
            `;
            
            document.getElementById('quiz-container').innerHTML = html;
            document.getElementById('currentQ').textContent = currentQuestion + 1;
            document.getElementById('progress').style.width = ((currentQuestion + 1) / shuffledQuestions.length * 100) + '%';
            answered = false;
        }

        function selectOption(index) {
            if (answered) return;
            answered = true;
            
            const q = shuffledQuestions[currentQuestion];
            const options = document.querySelectorAll('.option');
            const isCorrect = index === q.correct;
            
            // Track result
            results.push({
                question: q.question,
                tag: q.tag,
                topic: q.topic,
                correct: isCorrect,
                userAnswer: q.options[index],
                correctAnswer: q.options[q.correct]
            });
            
            options.forEach((opt, i) => {
                opt.classList.add('disabled');
                if (i === q.correct) {
                    opt.classList.add('correct');
                } else if (i === index && !isCorrect) {
                    opt.classList.add('incorrect');
                }
            });
            
            if (isCorrect) {
                score++;
                document.getElementById('score').textContent = score;
            }
            
            document.getElementById('explanation').classList.add('show');
            document.getElementById('nextBtn').disabled = false;
        }

        function nextQuestion() {
            currentQuestion++;
            if (currentQuestion >= shuffledQuestions.length) {
                showResults();
            } else {
                showQuestion();
            }
        }

        function showResults() {
            document.getElementById('quiz-container').classList.add('hidden');
            document.getElementById('results').classList.add('show');
            
            const percentage = Math.round((score / shuffledQuestions.length) * 100);
            document.getElementById('finalScore').textContent = percentage + '%';
            
            // Save results
            saveResults(percentage);
            
            let message = '';
            if (percentage >= 90) {
                message = 'üî• Excellent! You\'re ready to crush this interview!';
            } else if (percentage >= 70) {
                message = 'üëç Good job! Review the topics you missed and you\'ll be solid.';
            } else if (percentage >= 50) {
                message = 'üìö Getting there! Spend some time with the reading guides.';
            } else {
                message = 'üí™ Keep studying! Go through the cheat sheets again.';
            }
            document.getElementById('resultMessage').textContent = message;
            
            // Show history
            displayHistory();
        }
        
        function saveResults(percentage) {
            const history = JSON.parse(localStorage.getItem('quizHistory') || '[]');
            const attempt = {
                date: new Date().toISOString(),
                score: score,
                total: shuffledQuestions.length,
                percentage: percentage,
                results: results
            };
            history.unshift(attempt);
            // Keep last 10 attempts
            if (history.length > 10) history.pop();
            localStorage.setItem('quizHistory', JSON.stringify(history));
            localStorage.setItem('lastQuizResults', JSON.stringify(results));
        }
        
        function displayHistory() {
            const history = JSON.parse(localStorage.getItem('quizHistory') || '[]');
            const container = document.getElementById('historyList');
            
            if (history.length <= 1) {
                container.innerHTML = '<p style="color: #666;">Complete more quizzes to see your progress!</p>';
                return;
            }
            
            container.innerHTML = history.slice(1).map((h, i) => `
                <div class="history-item">
                    <div>
                        <span class="history-score" style="color: ${h.percentage >= 70 ? '#00ff88' : h.percentage >= 50 ? '#FF9800' : '#ff4444'}">${h.percentage}%</span>
                        <span style="color: #888;"> (${h.score}/${h.total})</span>
                    </div>
                    <span class="history-date">${new Date(h.date).toLocaleDateString()}</span>
                </div>
            `).join('');
        }
        
        function viewMatrix() {
            window.location.href = 'matrix.html';
        }

        function restartQuiz() {
            currentQuestion = 0;
            score = 0;
            document.getElementById('score').textContent = 0;
            document.getElementById('quiz-container').classList.remove('hidden');
            document.getElementById('results').classList.remove('show');
            init();
        }

        init();
    </script>
</body>
</html>
